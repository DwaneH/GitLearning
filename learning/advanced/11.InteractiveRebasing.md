
# Understanding and Using Interactive Rebasing

## What is Interactive Rebasing?

Interactive rebasing in Git allows you to rewrite, reorder, edit, or combine commits in your branch's history before sharing it with others.  
It is a powerful tool for cleaning up your commit history to make it more readable and logical.  
Unlike a regular rebase, interactive rebasing (`git rebase -i`) provides a user interface to choose how to modify commits.  

Key points about interactive rebasing:
- Used to edit, squash, reorder, or delete commits.
- Helps create a cleaner, more organized commit history.
- Best used on local branches before pushing to shared repositories.
- **NOTE!** Should be used cautiously, as it rewrites commit history.

---

## How Interactive Rebasing Works

The basic syntax for interactive rebasing is:

```bash
git rebase -i <commit>
```

Here, `<commit>` the commit hash or `HEAD~n` for the last `n` commits is used.

When you run this command:
1. Git opens an editor with a list of commits starting from the specified commit.
2. You can specify actions for each commit (see below actions).
3. After saving and closing the editor, Git applies the changes according to your instructions.

Common actions in the interactive rebase editor:
- `pick`: Keep the commit as is.
- `reword`: Keep the commit but edit its message.
- `squash`: Combine the commit with the previous one.
- `edit`: Pause the rebase to modify the commit.
- `drop`: Remove the commit entirely.

---

## Practical Example for Interactive Rebasing

Letâ€™s walk through an example of cleaning up a commit history using interactive rebasing:

1. Check your commit history:

   ```bash
   git log --oneline
   ```

   Output:
   ```
   abc1234 (HEAD -> feature) Fix typo in README
   def5678 Add new feature code
   ghi9101 Update README with feature details
   jkl1121 Initial feature commit
   ```

2. Suppose you want to combine the two README-related commits and reword another. Start an interactive rebase for the last three commits:

   ```bash
   git rebase -i HEAD~3
   ```

3. Your editor opens with something like (see the commits in the opposite direction now with newest at the bottom):

   ```
   pick jkl1121 Initial feature commit
   pick ghi9101 Update README with feature details
   pick def5678 Add new feature code
   pick abc1234 Fix typo in README
   ```

   Change it to:

   ```
   pick jkl1121 Initial feature commit
   reword def5678 Add new feature code
   squash ghi9101 Update README with feature details
   squash abc1234 Fix typo in README
   ```

4. Save and close the editor. Git will:
   - Keep the first commit (`jkl1121`) unchanged.
   - Prompt you to reword the commit message for `def5678`.
   - Combine `ghi9101` and `abc1234` into a single commit, asking you to edit the combined commit message.
   - Yes you can move the commits around

5. After completing the rebase, check the history again:

   ```bash
   git log --oneline
   ```

   Output:
   ```
   xyz7890 (HEAD -> feature) Add new feature with updated README
   jkl1121 Initial feature commit
   ```

   The history is now cleaner, with two commits instead of four.

---

## Conclusion

Interactive rebasing is a powerful tool for adjusting your commit history. Its key advantages include:
1. **Cleaner History**: Combine or reword commits to make the history more coherent.
2. **Flexibility**: Edit, reorder, or delete commits as needed.
3. **Professionalism**: Present a polished commit history to collaborators.

However, keep in mind:
- Rebasing rewrites history, so avoid using it on branches already shared with others.
- Conflicts may arise during rebasing, requiring manual resolution.
- Always double-check your changes with `git log` after rebasing.

Use interactive rebasing if needed on your local branch before pushing, but be cautious to avoid disrupting collaborative workflows.